# Vector Operations Developer Guide

This guide covers how to work with vector embeddings and similarity search in the Mykadoo platform.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Getting Started](#getting-started)
3. [Working with Embeddings](#working-with-embeddings)
4. [Similarity Search](#similarity-search)
5. [Hybrid Search](#hybrid-search)
6. [Personalized Recommendations](#personalized-recommendations)
7. [Performance Optimization](#performance-optimization)
8. [Testing](#testing)
9. [Best Practices](#best-practices)

---

## Architecture Overview

The vector system uses PostgreSQL with pgvector for storing and querying 1536-dimensional embeddings generated by OpenAI's text-embedding-3-small model.

### Key Components

```
apps/api/src/app/vector/
├── vector.module.ts              # Module configuration
├── vector.service.ts             # Main facade service
├── embedding.service.ts          # OpenAI embedding generation
├── vector-storage.service.ts     # Database storage operations
├── similarity-search.service.ts  # Similarity queries
├── semantic-search.service.ts    # Full semantic search with RRF
├── query-cache.service.ts        # Two-level caching (L1/L2)
├── vector-pool.service.ts        # Dedicated connection pooling
├── vector-metrics.service.ts     # Prometheus metrics
└── vector-logging.service.ts     # Structured logging
```

### Data Flow

```
User Query → VectorService → EmbeddingService → OpenAI API
                ↓
            QueryCacheService (L1: Memory, L2: Database)
                ↓
            SimilaritySearchService → VectorPoolService → PostgreSQL/pgvector
                ↓
            Results (sorted by similarity)
```

---

## Getting Started

### Prerequisites

1. PostgreSQL 16+ with pgvector extension
2. OpenAI API key with embedding access
3. Node.js 18+ and Yarn

### Environment Variables

```env
# Required
OPENAI_API_KEY=sk-...

# Optional (with defaults)
VECTOR_POOL_MAX=10
VECTOR_POOL_MIN=2
VECTOR_CACHE_TTL_SECONDS=3600
EMBEDDING_MODEL=text-embedding-3-small
```

### Database Setup

The vector extension and tables are created via migrations:

```bash
# Run migrations
yarn nx prisma:migrate api

# Verify pgvector is enabled
psql -d mykadoo -c "SELECT * FROM pg_extension WHERE extname = 'vector';"
```

---

## Working with Embeddings

### Generating Product Embeddings

```typescript
import { VectorService } from './vector/vector.service';

@Injectable()
export class ProductService {
  constructor(private vectorService: VectorService) {}

  async createProduct(data: CreateProductDto) {
    // Create product in database
    const product = await this.prisma.product.create({ data });

    // Generate and store embedding
    const cost = await this.vectorService.generateProductEmbedding(
      product.id,
      product.title,
      product.description,
      product.category,
      product.tags
    );

    console.log(`Embedding generated. Cost: $${cost.estimatedCost}`);
    return product;
  }
}
```

### Batch Embedding Generation

For bulk operations, use batch embedding to reduce API costs:

```typescript
const products = await this.prisma.product.findMany({
  where: { embedding: null },
  take: 100,
});

const result = await this.vectorService.generateBatchProductEmbeddings(
  products.map(p => ({
    id: p.id,
    title: p.title,
    description: p.description,
    category: p.category,
    tags: p.tags,
  })),
  50 // batch size
);

console.log(`Processed: ${result.processed}, Cost: $${result.cost.estimatedCost}`);
```

### Query Embeddings

Query embeddings are generated on-the-fly and cached:

```typescript
const { embedding, cost } = await this.vectorService.generateSearchEmbedding(
  searchId,
  'birthday gift for mom'
);
```

---

## Similarity Search

### Basic Similarity Search

```typescript
const results = await this.vectorService.findSimilarProducts(
  'gift for mom',
  {
    matchThreshold: 0.7,  // Minimum similarity score
    matchCount: 10,       // Maximum results
  }
);

results.forEach(product => {
  console.log(`${product.title}: ${(product.similarity * 100).toFixed(1)}% match`);
});
```

### Find Similar Products

```typescript
const similar = await this.vectorService.findSimilarToProduct(
  productId,
  {
    matchThreshold: 0.8,
    matchCount: 5,
    categoryFilter: product.category, // Same category only
  }
);
```

### Filtered Search

```typescript
const results = await this.vectorService.findSimilarProducts(
  'tech gadgets',
  {
    categoryFilter: 'Electronics',
    minPrice: 20,
    maxPrice: 100,
    matchThreshold: 0.6,
    matchCount: 20,
  }
);
```

---

## Hybrid Search

Hybrid search combines keyword matching with semantic similarity using Reciprocal Rank Fusion (RRF).

```typescript
import { SemanticSearchService } from './vector/semantic-search.service';

@Injectable()
export class SearchService {
  constructor(private semanticSearch: SemanticSearchService) {}

  async search(query: string) {
    const results = await this.semanticSearch.hybridSearch({
      query,
      keywordWeight: 0.3,   // PostgreSQL full-text search
      semanticWeight: 0.7,  // pgvector similarity
      rrfConstant: 60,      // RRF ranking constant
      maxResults: 20,
    });

    return results;
  }
}
```

### Query Expansion

Enable query expansion for better recall:

```typescript
const results = await this.semanticSearch.searchWithExpansion({
  query: 'gift for mom',
  expandSynonyms: true,  // mom → mother
  expandCategories: true, // gift → present, surprise
});
```

---

## Personalized Recommendations

### User Preference Vectors

User preferences are learned from interactions:

```typescript
import { UserPreferenceService } from './vector/user-preference.service';

// Track user interaction
await this.userPreferenceService.trackInteraction({
  userId: 'user-123',
  productId: 'product-456',
  type: 'CLICK', // VIEW, CLICK, ADD_TO_CART, PURCHASE
  timestamp: new Date(),
});

// Update preference vector (aggregates recent interactions)
await this.userPreferenceService.updateUserPreferences('user-123');
```

### Getting Recommendations

```typescript
import { RecommendationEngineService } from './vector/recommendation-engine.service';

const recommendations = await this.recommendationEngine.getRecommendations({
  userId: 'user-123',
  context: {
    occasion: 'birthday',
    recipient: { age: 35, gender: 'female' },
    budget: { min: 20, max: 100 },
  },
  count: 10,
  diversityThreshold: 0.3, // MMR diversity
});

// Each recommendation includes explanation
recommendations.forEach(rec => {
  console.log(`${rec.product.title}`);
  console.log(`  Reason: ${rec.explanation.primaryReason}`);
  console.log(`  Confidence: ${(rec.confidence * 100).toFixed(0)}%`);
});
```

---

## Performance Optimization

### Query Caching

The system uses two-level caching:

- **L1 Cache (Memory)**: 5-minute TTL, fastest access
- **L2 Cache (Database)**: 1-hour TTL, persistent

```typescript
import { QueryCacheService } from './vector/query-cache.service';

// Cache is used automatically, but you can interact directly:
const cacheStats = await this.queryCacheService.getStats();
console.log(`Hit rate: ${(cacheStats.hitRate * 100).toFixed(1)}%`);

// Invalidate cache for a product
await this.queryCacheService.invalidateByProduct('product-123');

// Warm cache with popular queries
await this.queryCacheService.warmCache([
  'gift for mom',
  'birthday present',
  'tech gadgets',
]);
```

### Connection Pooling

A dedicated connection pool is used for vector queries:

```typescript
import { VectorPoolService } from './vector/vector-pool.service';

// Execute raw query with dedicated pool
const results = await this.vectorPoolService.executeQuery(`
  SELECT * FROM find_similar_products($1::vector, $2, $3, NULL, NULL, NULL)
`, [vectorString, 0.7, 10]);

// Check pool health
const poolStats = await this.vectorPoolService.getPoolStats();
console.log(`Connections: ${poolStats.acquiredConnections}/${poolStats.totalConnections}`);
```

### HNSW Index Tuning

Adjust ef_search for latency vs accuracy tradeoff:

```typescript
// Higher ef_search = better recall, slower queries
await this.vectorPoolService.setEfSearch(100); // Default: 60

// Run benchmark to find optimal value
const tuningResults = await this.benchmarkService.tuneEfSearch({
  minEfSearch: 40,
  maxEfSearch: 200,
  step: 20,
  groundTruthQuery: 'test query',
});
```

---

## Testing

### Unit Tests

```typescript
describe('EmbeddingService', () => {
  let service: EmbeddingService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        EmbeddingService,
        { provide: ConfigService, useValue: { get: () => 'test-key' } },
      ],
    }).compile();

    service = module.get<EmbeddingService>(EmbeddingService);
  });

  it('should validate embedding dimensions', () => {
    const valid = service.validateEmbedding(Array(1536).fill(0.1));
    expect(valid).toBe(true);
  });
});
```

### Integration Tests

```typescript
describe('Vector Search Integration', () => {
  it('should return similar products', async () => {
    const results = await request(app.getHttpServer())
      .post('/vectors/search')
      .send({ query: 'test query' })
      .expect(200);

    expect(results.body.results).toBeDefined();
    expect(Array.isArray(results.body.results)).toBe(true);
  });
});
```

### Benchmark Tests

```typescript
it('should complete search within latency threshold', async () => {
  const iterations = 100;
  const latencies: number[] = [];

  for (let i = 0; i < iterations; i++) {
    const start = Date.now();
    await vectorService.findSimilarProducts('test');
    latencies.push(Date.now() - start);
  }

  const p95 = latencies.sort((a, b) => a - b)[Math.floor(iterations * 0.95)];
  expect(p95).toBeLessThan(500); // 500ms threshold
});
```

---

## Best Practices

### 1. Embedding Quality

- Include relevant product metadata (title, description, category, tags)
- Truncate long descriptions to 500 characters to manage costs
- Re-generate embeddings when products are significantly updated

### 2. Search Optimization

- Use appropriate match thresholds (0.6-0.8 for most use cases)
- Limit result counts to what's needed (typically 10-20)
- Apply category/price filters when possible to reduce search space

### 3. Cost Management

- Use batch embedding for bulk operations
- Cache query embeddings (identical queries = same embedding)
- Monitor token usage via metrics dashboard

### 4. Error Handling

```typescript
try {
  const results = await this.vectorService.findSimilarProducts(query);
  return results;
} catch (error) {
  if (error.message.includes('Rate limit')) {
    // Retry with exponential backoff
    await this.retryWithBackoff(() => this.vectorService.findSimilarProducts(query));
  } else if (error.message.includes('Invalid embedding')) {
    // Fall back to keyword search
    return this.keywordSearch(query);
  }
  throw error;
}
```

### 5. Monitoring

Use the built-in metrics endpoints:

```bash
# Prometheus metrics
curl http://localhost:3000/api/vector-monitoring/metrics

# Health check
curl http://localhost:3000/api/vector-monitoring/health

# Dashboard data
curl http://localhost:3000/api/vector-monitoring/dashboard
```

---

## Troubleshooting

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| Empty search results | Threshold too high | Lower `matchThreshold` to 0.5-0.6 |
| Slow queries | Missing index | Verify HNSW index exists |
| Rate limiting | Too many API calls | Use batch embedding, add caching |
| Memory issues | Large result sets | Limit `matchCount`, use pagination |

### Debug Mode

Enable debug logging:

```env
LOG_LEVEL=debug
VECTOR_DEBUG=true
```

### Performance Profiling

```typescript
// Enable query timing
const start = Date.now();
const results = await vectorService.findSimilarProducts(query);
console.log(`Query time: ${Date.now() - start}ms`);

// Check index usage
const explain = await prisma.$queryRaw`
  EXPLAIN ANALYZE
  SELECT * FROM find_similar_products($1::vector, 0.7, 10, NULL, NULL, NULL)
`;
console.log(explain);
```
